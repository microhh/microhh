/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                                                                  */
/* The ODE Jacobian of Chemical Model File                          */
/*                                                                  */
/* Generated by KPP-2.2.3 symbolic chemistry Kinetics PreProcessor  */
/*       (http://www.cs.vt.edu/~asandu/Software/KPP)                */
/* KPP is distributed under GPL, the general public licence         */
/*       (http://www.gnu.org/copyleft/gpl.html)                     */
/* (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa           */
/* (C) 1997-2005, A. Sandu, Michigan Tech, Virginia Tech            */
/*     With important contributions from:                           */
/*        M. Damian, Villanova University, USA                      */
/*        R. Sander, Max-Planck Institute for Chemistry, Mainz, Germany */
/*                                                                  */
/* File                 : mhh_Jacobian.c                            */
/* Time                 : Tue Oct 18 15:45:13 2022                  */
/* Working directory    : /home/WUR/krol005/kpp/examples            */
/* Equation file        : mhh.kpp                                   */
/* Output root filename : mhh                                       */
/*                                                                  */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "mhh_Parameters.h"
#include "mhh_Global.h"
#include "mhh_Sparse.h"


/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
/*                                                                  */
/* Jac_SP - the Jacobian of Variables in sparse matrix representation */
/*   Arguments :                                                    */
/*      V         - Concentrations of variable species (local)      */
/*      F         - Concentrations of fixed species (local)         */
/*      RCT       - Rate constants (local)                          */
/*      JVS       - sparse Jacobian of variables                    */
/*                                                                  */
/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

void Jac_SP( 
  double V[],                            /* Concentrations of variable species (local) */
  double F[],                            /* Concentrations of fixed species (local) */
  double RCT[],                          /* Rate constants (local) */
  double JVS[]                           /* sparse Jacobian of variables */
)
{

/* Local variables                                                  */
double B[70];                            /* Temporary array */

// B(0) = dA(0)/dV(7)
  B[0] = RCT[0]*F[3];
// B(2) = dA(1)/dV(7)
  B[2] = RCT[1]*F[4];
// B(7) = dA(4)/dV(1)
  B[7] = RCT[4]*F[3];
// B(10) = dA(6)/dV(7)
  B[10] = RCT[6]*V[8];
// B(11) = dA(6)/dV(8)
  B[11] = RCT[6]*V[7];
// B(12) = dA(7)/dV(6)
  B[12] = RCT[7]*V[7];
// B(13) = dA(7)/dV(7)
  B[13] = RCT[7]*V[6];
// B(14) = dA(8)/dV(8)
  B[14] = RCT[8]*F[6];
// B(16) = dA(9)/dV(6)
  B[16] = RCT[9]*F[6];
// B(19) = dA(11)/dV(8)
  B[19] = RCT[11]*F[4];
// B(21) = dA(12)/dV(6)
  B[21] = RCT[12]*F[3];
// B(25) = dA(14)/dV(0)
  B[25] = RCT[14]*F[3];
// B(34) = dA(19)/dV(8)
  B[34] = RCT[19]*F[5];
// B(38) = dA(21)/dV(4)
  B[38] = RCT[21]*F[3];
// B(40) = dA(22)/dV(3)
  B[40] = RCT[22]*F[3];
// B(42) = dA(23)/dV(3)
  B[42] = 5.8e-16*F[6];
// B(44) = dA(24)/dV(2)
  B[44] = RCT[24]*F[3];
// B(47) = dA(26)/dV(5)
  B[47] = RCT[26]*V[7];
// B(48) = dA(26)/dV(7)
  B[48] = RCT[26]*V[5];
// B(49) = dA(27)/dV(5)
  B[49] = RCT[27]*F[3];
// B(51) = dA(28)/dV(5)
  B[51] = RCT[28]*F[6];
// B(53) = dA(29)/dV(7)
  B[53] = RCT[29];
// B(54) = dA(30)/dV(6)
  B[54] = RCT[30];
// B(57) = dA(33)/dV(4)
  B[57] = RCT[33];
// B(58) = dA(34)/dV(3)
  B[58] = RCT[34];
// B(59) = dA(35)/dV(3)
  B[59] = RCT[35];
// B(60) = dA(36)/dV(1)
  B[60] = RCT[36];
// B(63) = dA(39)/dV(7)
  B[63] = RCT[39];
// B(64) = dA(40)/dV(8)
  B[64] = RCT[40];
// B(65) = dA(41)/dV(6)
  B[65] = RCT[41];
// B(66) = dA(42)/dV(0)
  B[66] = RCT[42];
// B(67) = dA(43)/dV(1)
  B[67] = RCT[43];
// B(68) = dA(44)/dV(3)
  B[68] = RCT[44];
// B(69) = dA(45)/dV(4)
  B[69] = RCT[45];

// Construct the Jacobian terms from B's
// JVS(0) = Jac_FULL(0,0)
  JVS[0] = -B[25]-B[66];
// JVS(1) = Jac_FULL(0,3)
  JVS[1] = B[42];
// JVS(2) = Jac_FULL(0,6)
  JVS[2] = B[21];
// JVS(3) = Jac_FULL(1,1)
  JVS[3] = -B[7]-B[60]-B[67];
// JVS(4) = Jac_FULL(2,2)
  JVS[4] = -B[44];
// JVS(5) = Jac_FULL(2,3)
  JVS[5] = B[40]+B[58]+B[59];
// JVS(6) = Jac_FULL(2,5)
  JVS[6] = 0.56*B[47];
// JVS(7) = Jac_FULL(2,7)
  JVS[7] = 0.56*B[48];
// JVS(8) = Jac_FULL(3,3)
  JVS[8] = -B[40]-B[42]-B[58]-B[59]-B[68];
// JVS(9) = Jac_FULL(3,4)
  JVS[9] = 0.4*B[38]+B[57];
// JVS(10) = Jac_FULL(3,5)
  JVS[10] = 1.04*B[47]+1.5*B[49];
// JVS(11) = Jac_FULL(3,7)
  JVS[11] = 1.04*B[48];
// JVS(12) = Jac_FULL(3,8)
  JVS[12] = B[34];
// JVS(13) = Jac_FULL(4,4)
  JVS[13] = -B[38]-B[57]-B[69];
// JVS(14) = Jac_FULL(5,5)
  JVS[14] = -B[47]-B[49]-B[51];
// JVS(15) = Jac_FULL(5,7)
  JVS[15] = -B[48];
// JVS(16) = Jac_FULL(6,6)
  JVS[16] = -B[12]-B[16]-B[21]-B[54]-B[65];
// JVS(17) = Jac_FULL(6,7)
  JVS[17] = B[10]-B[13];
// JVS(18) = Jac_FULL(6,8)
  JVS[18] = B[11]+2*B[14]+B[19]+B[34];
// JVS(19) = Jac_FULL(7,5)
  JVS[19] = -B[47];
// JVS(20) = Jac_FULL(7,6)
  JVS[20] = -B[12]+B[54];
// JVS(21) = Jac_FULL(7,7)
  JVS[21] = -B[0]-B[2]-B[10]-B[13]-B[48]-B[53]-B[63];
// JVS(22) = Jac_FULL(7,8)
  JVS[22] = -B[11];
// JVS(23) = Jac_FULL(8,6)
  JVS[23] = B[54];
// JVS(24) = Jac_FULL(8,7)
  JVS[24] = -B[10];
// JVS(25) = Jac_FULL(8,8)
  JVS[25] = -B[11]-B[14]-B[19]-B[34]-B[64];
}

// End of Jac_SP function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Jac_SP_Vec - function for sparse multiplication: sparse Jacobian times vector
//   Arguments :
//      JVS       - sparse Jacobian of variables
//      UV        - User vector for variables
//      JUV       - Jacobian times user vector
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void Jac_SP_Vec( 
  double JVS[LU_NONZERO],                /* sparse Jacobian of variables */
  double UV[NVAR],                       /* User vector for variables */
  double JUV[NVAR]                       /* Jacobian times user vector */
)
{
  JUV[0] = JVS[0]*UV[0]+JVS[1]*UV[3]+JVS[2]*UV[6];
  JUV[1] = JVS[3]*UV[1];
  JUV[2] = JVS[4]*UV[2]+JVS[5]*UV[3]+JVS[6]*UV[5]+JVS[7]*UV[7];
  JUV[3] = JVS[8]*UV[3]+JVS[9]*UV[4]+JVS[10]*UV[5]+JVS[11]*UV[7]
          +JVS[12]*UV[8];
  JUV[4] = JVS[13]*UV[4];
  JUV[5] = JVS[14]*UV[5]+JVS[15]*UV[7];
  JUV[6] = JVS[16]*UV[6]+JVS[17]*UV[7]+JVS[18]*UV[8];
  JUV[7] = JVS[19]*UV[5]+JVS[20]*UV[6]+JVS[21]*UV[7]+JVS[22]*UV[8];
  JUV[8] = JVS[23]*UV[6]+JVS[24]*UV[7]+JVS[25]*UV[8];
}

// End of Jac_SP_Vec function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// JacTR_SP_Vec - sparse multiplication: sparse Jacobian transposed times vector
//   Arguments :
//      JVS       - sparse Jacobian of variables
//      UV        - User vector for variables
//      JTUV      - Jacobian transposed times user vector
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

void JacTR_SP_Vec( 
  double JVS[LU_NONZERO],                /* sparse Jacobian of variables */
  double UV[NVAR],                       /* User vector for variables */
  double JTUV[NVAR]                      /* Jacobian transposed times user vector */
)
{
  JTUV[0] = JVS[0]*UV[0];
  JTUV[1] = JVS[3]*UV[1];
  JTUV[2] = JVS[4]*UV[2];
  JTUV[3] = JVS[1]*UV[0]+JVS[5]*UV[2]+JVS[8]*UV[3];
  JTUV[4] = JVS[9]*UV[3]+JVS[13]*UV[4];
  JTUV[5] = JVS[6]*UV[2]+JVS[10]*UV[3]+JVS[14]*UV[5]+JVS[19]*UV[7];
  JTUV[6] = JVS[2]*UV[0]+JVS[16]*UV[6]+JVS[20]*UV[7]+JVS[23]*UV[8];
  JTUV[7] = JVS[7]*UV[2]+JVS[11]*UV[3]+JVS[15]*UV[5]+JVS[17]*UV[6]
           +JVS[21]*UV[7]+JVS[24]*UV[8];
  JTUV[8] = JVS[12]*UV[3]+JVS[18]*UV[6]+JVS[22]*UV[7]+JVS[25]*UV[8];
}

// End of JacTR_SP_Vec function
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

