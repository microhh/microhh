// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// Numerical Integrator (Time-Stepping) File
// 
// Generated by KPP-3.3.0 symbolic chemistry Kinetics PreProcessor
//       (https:/github.com/KineticPreProcessor/KPP
// KPP is distributed under GPL, the general public licence
//       (http://www.gnu.org/copyleft/gpl.html)
// (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
// (C) 1997-2022, A. Sandu, Michigan Tech, Virginia Tech
//     With important contributions from:
//        M. Damian,   Villanova University, Philadelphia, PA, USA
//        R. Sander,   Max-Planck Institute for Chemistry, Mainz, Germany
//        M. Long,     Renaissance Fiber, LLC, North Carolina, USA
//        H. Lin,      Harvard University, Cambridge, MA, USA
//        R. Yantosca, Harvard University, Cambridge, MA, USA
// 
// File                 : mhh_Integrator.c
// Equation file        : mhh.kpp
// Output root filename : mhh
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "mhh_Parameters.h"
#include "mhh_Global.h"
// #include "mhh_Sparse.h"


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// 
// INTEGRATE - Integrator routine
//   Arguments :
//      TIN       - Start Time for Integration
//      TOUT      - End Time for Integration
// 
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#define MAX(a,b) ( ((a) >= (b)) ?(a):(b)  )
#define MIN(b,c) ( ((b) <  (c)) ?(b):(c)  )
// #define ABS(x)   ( ((x) >=  0 ) ?(x):(-x) )
#define SQRT(d)  ( pow((d),0.5)  )
#define SIGN(x,y)( ( (x*y) >= 0 ) ?(x):(-x) )/* Sign transfer function */
#define MOD(A,B) (int)((A)%(B))

/* ~~~> Numerical constants    */
#define  ZERO     (double)0.0
#define  ONE      (double)1.0

#define ABS(x)   fabs(x)

/* 声明 Fun 函数，如果可能，建议在编译时开启跨文件优化 (LTO) */
extern void Fun(double Y[], double FIX[], double RCONST[], double Ydot[], double A[]);

/* 辅助宏 */
#ifndef MAX
#endif

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* 函数接口：MicroHH 只会传入开始时间 TIN 和结束时间 TOUT              */
/* 其他数据（浓度、容差等）全部通过全局变量 VAR, ATOL, RTOL 自动获取      */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/


void INTEGRATE(double TIN, double TOUT)
{
    /* 1. 静态常量：使用 static const 确保只在内存中存在一份，减少栈分配开销 */
    static const double 
        a21 = 0.2, a31 = 0.075, a32 = 0.225, a41 = 44.0/45.0, a42 = -56.0/15.0, a43 = 32.0/9.0,
        a51 = 19372.0/6561.0, a52 = -25360.0/2187.0, a53 = 64448.0/6561.0, a54 = -212.0/729.0,
        a61 = 9017.0/3168.0, a62 = -355.0/33.0, a63 = 46732.0/5247.0, a64 = 49.0/176.0, a65 = -5103.0/18656.0,
        a71 = 35.0/384.0, a73 = 500.0/1113.0, a74 = 125.0/192.0, a75 = -2187.0/6784.0, a76 = 11.0/84.0,
        e1 = 71.0/57600.0, e3 = -71.0/16695.0, e4 = 71.0/1920.0, e5 = -17253.0/339200.0, e6 = 22.0/525.0, e7 = -0.025;

    /* 2. 局部数组：MPI 进程私有。使用 restrict 关键字告知编译器数组不重叠，利于 SIMD 向量化 */
    double k1[NVAR], k2[NVAR], k3[NVAR], k4[NVAR], k5[NVAR], k6[NVAR], k7[NVAR];
    double y_temp[NVAR], A[NREACT];
    
    double t = TIN;
    /* 1. 初始步长可以大胆一点 */
    double h = fmax(1.0e-4, (TOUT - TIN) / 100.0); 
    
    const double h_min = 1.0e-12; // 建议不要超过 1e-8，除非你真的不在乎结果
    const double h_max_limit = 300.0; 

    Fun(VAR, FIX, RCONST, k1, A);

    while (t < TOUT) {
        if (t + h > TOUT) h = TOUT - t;
        if (h < 1e-14) break;

        int step_accepted = 0;
        while (!step_accepted) {
            /* Stage 2-7 计算：手动优化循环，配合编译器 -O3 自动向量化 */
            for(int i=0; i<NVAR; i++) y_temp[i] = VAR[i] + h * (a21*k1[i]);
            Fun(y_temp, FIX, RCONST, k2, A);

            for(int i=0; i<NVAR; i++) y_temp[i] = VAR[i] + h * (a31*k1[i] + a32*k2[i]);
            Fun(y_temp, FIX, RCONST, k3, A);

            for(int i=0; i<NVAR; i++) y_temp[i] = VAR[i] + h * (a41*k1[i] + a42*k2[i] + a43*k3[i]);
            Fun(y_temp, FIX, RCONST, k4, A);

            for(int i=0; i<NVAR; i++) y_temp[i] = VAR[i] + h * (a51*k1[i] + a52*k2[i] + a53*k3[i] + a54*k4[i]);
            Fun(y_temp, FIX, RCONST, k5, A);

            for(int i=0; i<NVAR; i++) y_temp[i] = VAR[i] + h * (a61*k1[i] + a62*k2[i] + a63*k3[i] + a64*k4[i] + a65*k5[i]);
            Fun(y_temp, FIX, RCONST, k6, A);

            for(int i=0; i<NVAR; i++) y_temp[i] = VAR[i] + h * (a71*k1[i] + a73*k3[i] + a74*k4[i] + a75*k5[i] + a76*k6[i]);
            Fun(y_temp, FIX, RCONST, k7, A);

            /* 2. 极速误差评估 */
            double err_max = 0.0;
            for(int i=0; i<NVAR; i++) {
                double err_i = h * (e1*k1[i] + e3*k3[i] + e4*k4[i] + e5*k5[i] + e6*k6[i] + e7*k7[i]);
                // 使用你设置的高容差
                double scal = 10000.0 + fmax(fabs(VAR[i]), fabs(y_temp[i])) * 0.01;
                double ratio = fabs(err_i) / scal;
                if (ratio > err_max) err_max = ratio;
            }

            if (err_max <= 1.0) {
                step_accepted = 1;
                t += h;
                for(int i=0; i<NVAR; i++) {
                    VAR[i] = fmax(0.0, y_temp[i]);
                    k1[i] = k7[i];
                }
                
                /* 3. 步长增长预测优化 */
                // 因为容差很松，我们可以让步长增长得更激进一点
                if (err_max < 0.5) {
                    h *= 1.5; // 发现误差很小，直接放大 1.5 倍
                } else {
                    double factor = 0.9 * pow(err_max, -0.2);
                    h *= fmin(2.0, factor);
                }
                h = fmin(h, h_max_limit);
            } else {
                /* 4. 拒绝逻辑：快速收缩 */
                // 使用 sqrt(sqrt) 替代 pow
                double factor = 0.9 * sqrt(sqrt(1.0 / err_max));
                h *= fmax(0.1, factor);

                if (h < h_min) {
                    // 强制通过逻辑（在这种高容差下通常不会触发，除非系统极度不稳定）
                    for(int i=0; i<NVAR; i++) VAR[i] = fmax(0.0, VAR[i] + h_min * k1[i]);
                    t += h_min;
                    Fun(VAR, FIX, RCONST, k1, A);
                    step_accepted = 1;
                }
            }
        }
    }
}


// void INTEGRATE(double TIN, double TOUT)
// {
//     /* --- 1. 变量定义区 --- */
    
//     /* DP5 的 7 个中间斜率向量 k1...k7 */
//     /* 使用 static 关键字是为了防止栈溢出，并提高大数组的分配效率 */
//     static double k1[NVAR], k2[NVAR], k3[NVAR], k4[NVAR]; 
//     static double k5[NVAR], k6[NVAR], k7[NVAR];
    
//     /* 临时存放浓度的数组 */
//     static double y_temp[NVAR];

//     /* 时间和步长变量 */
//     double t, h, h_new;
    
//     /* 误差控制变量 */
//     double err_max, scal, err_i, ratio;

//     double A[NREACT];
    
//     /* 循环计数器 */
//     int i, step_accepted;

//     /* --- 2. 参数设置区 (根据你的模型调整) --- */
    
//     /* 最小步长：遇到 SDIRK 报错那种刚性冲击时，允许的最小步长 */
//     const double h_min = 1.0e-12;  
    
//     /* 最大步长：物理限制，防止步子迈太大错过日出日落 */
//     const double h_max_limit = 300.0; 

//     /* --- 3. DP5 算法系数 (不要动) --- */
//     const double c2 = 0.2, c3 = 0.3, c4 = 0.8, c5 = 8.0/9.0;
//     const double a21 = 0.2;
//     const double a31 = 3.0/40.0, a32 = 9.0/40.0;
//     const double a41 = 44.0/45.0, a42 = -56.0/15.0, a43 = 32.0/9.0;
//     const double a51 = 19372.0/6561.0, a52 = -25360.0/2187.0, a53 = 64448.0/6561.0, a54 = -212.0/729.0;
//     const double a61 = 9017.0/3168.0, a62 = -355.0/33.0, a63 = 46732.0/5247.0, a64 = 49.0/176.0, a65 = -5103.0/18656.0;
//     const double a71 = 35.0/384.0, a73 = 500.0/1113.0, a74 = 125.0/192.0, a75 = -2187.0/6784.0, a76 = 11.0/84.0;
//     const double e1 = 71.0/57600.0, e3 = -71.0/16695.0, e4 = 71.0/1920.0, e5 = -17253.0/339200.0, e6 = 22.0/525.0, e7 = -1.0/40.0;

//     /* --- 4. 初始化 --- */
//     t = TIN;
//     h = 1.0e-2; /* 初始试探步长 0.01秒 */

//     /* 计算第一步的导数 k1 = Fun(t, y) */
//     /* 注意：这里直接传入全局变量 VAR, FIX, RCONST */
//     Fun(VAR, FIX, RCONST, k1, A);

//     /* --- 5. 时间积分主循环 --- */
//     while (t < TOUT) {
        
//         /* 保证最后一步正好落在 TOUT 上 */
//         if (t + h > TOUT) {
//             h = TOUT - t;
//             if (h < 1e-14) break; /* 剩余时间太短，直接结束 */
//         }

//         step_accepted = 0;

//         /* --- 6. 尝试迈出一步 --- */
//         while (!step_accepted) {
            
//             /* 计算中间点 (Stage 2-7) */
//             /* 每次计算前，先算出 y_temp，然后调用 Fun 算出 k */
            
//             /* Stage 2 */
//             for(i=0; i<NVAR; i++) y_temp[i] = VAR[i] + h * (a21*k1[i]);
//             Fun(y_temp, FIX, RCONST, k2, A);

//             /* Stage 3 */
//             for(i=0; i<NVAR; i++) y_temp[i] = VAR[i] + h * (a31*k1[i] + a32*k2[i]);
//             Fun(y_temp, FIX, RCONST, k3, A);

//             /* Stage 4 */
//             for(i=0; i<NVAR; i++) y_temp[i] = VAR[i] + h * (a41*k1[i] + a42*k2[i] + a43*k3[i]);
//             Fun(y_temp, FIX, RCONST, k4, A);

//             /* Stage 5 */
//             for(i=0; i<NVAR; i++) y_temp[i] = VAR[i] + h * (a51*k1[i] + a52*k2[i] + a53*k3[i] + a54*k4[i]);
//             Fun(y_temp, FIX, RCONST, k5, A);

//             /* Stage 6 */
//             for(i=0; i<NVAR; i++) y_temp[i] = VAR[i] + h * (a61*k1[i] + a62*k2[i] + a63*k3[i] + a64*k4[i] + a65*k5[i]);
//             Fun(y_temp, FIX, RCONST, k6, A);

//             /* Stage 7 (这是 5阶精度的预测结果) */
//             for(i=0; i<NVAR; i++) y_temp[i] = VAR[i] + h * (a71*k1[i] + a73*k3[i] + a74*k4[i] + a75*k5[i] + a76*k6[i]);
//             Fun(y_temp, FIX, RCONST, k7, A);

//             /* --- 7. 误差检查 --- */
//             err_max = 0.0;
//             for(i=0; i<NVAR; i++) {
//                 /* 估算误差 */
//                 err_i = h * (e1*k1[i] + e3*k3[i] + e4*k4[i] + e5*k5[i] + e6*k6[i] + e7*k7[i]);
                
//                 /* 计算容差标准 (这是关键！) */
//                 /* 使用全局变量 ATOL[i] 和 RTOL[i] */
//                 scal = ATOL[i] + MAX(fabs(VAR[i]), fabs(y_temp[i])) * RTOL[i];
//                 if (scal < 1.0e-20) scal = 1.0e-20; 

//                 ratio = fabs(err_i) / scal;
//                 if (ratio > err_max) err_max = ratio;
//             }

//             /* --- 8. 决策：接受还是拒绝？ --- */
//             if (err_max <= 1.0) {
//                 /* === 接受 === */
//                 step_accepted = 1;
//                 t += h;
                
//                 /* 更新全局变量 VAR */
//                 for(i=0; i<NVAR; i++) {
//                     VAR[i] = y_temp[i];
//                     /* 必须做：防止负浓度 */
//                     if (VAR[i] < 0.0) VAR[i] = 0.0;
//                 }

//                 /* 准备下一步 (FSAL特性: 下一步的k1就是这一步的k7) */
//                 for(i=0; i<NVAR; i++) k1[i] = k7[i];

//                 /* 放大步长 */
//                 if (err_max < 1.0e-10) err_max = 1.0e-10;
//                 double factor = 0.9 * pow(1.0/err_max, 0.2);
//                 if (factor > 5.0) factor = 5.0;
//                 h *= factor;
//                 if (h > h_max_limit) h = h_max_limit;

//             } else {
//                 /* === 拒绝 === */
//                 /* 缩小步长 */
//                 double factor = 0.9 * pow(1.0/err_max, 0.25);
//                 if (factor < 0.1) factor = 0.1;
//                 h *= factor;

//                 /* === 强制通过逻辑 (防止 SDIRK 式的崩溃) === */
//                 if (h < h_min) {
//                     h = h_min;
//                     /* 强制用一阶欧拉法走一小步，跳过难算的坑 */
//                     for(i=0; i<NVAR; i++) {
//                         VAR[i] += h * k1[i];
//                         if (VAR[i] < 0.0) VAR[i] = 0.0;
//                     }
//                     t += h;
//                     Fun(VAR, FIX, RCONST, k1, A); /* 重新算 k1 */
//                     step_accepted = 1; /* 强制标记为成功 */
//                 }
//             }
//         } 
//     }
// }

